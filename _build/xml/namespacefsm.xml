<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="namespacefsm" kind="namespace" language="Python">
    <compoundname>fsm</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacefsm_1a973dbd0b67087a3e7a64abd7ae573b99" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>def</type>
        <definition>def fsm.main</definition>
        <argsstring>()</argsstring>
        <name>main</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>This function initializes the finite state machine node, called _smach_finite_state_machine_.
It also creates the helper object to make it easier to access shared variables and use some functions.
It is important to note that the SMACH machine needs the definition of all the outcomes needed to pass from one state to another: in this way if the execute of one state returned a transition that is not included, the machine does not return an error or does not remain stuck because not knowing what to do.
The machine includes also one sub-machine, since we have four main states and one of them can be split into tow others to have a more modular architecture.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/root/ros_ws/src/EXPROBLAB_Assignment2/scripts/fsm.py" line="44" column="1" bodyfile="/root/ros_ws/src/EXPROBLAB_Assignment2/scripts/fsm.py" bodystart="44" bodyend="149"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><verbatim>.. module:: fsm
    :platform: ROS
    :synopsis: Script for the initialization of the Finite State Machine.

.. moduleauthor:: Matteo Maragliano 4636216@studenti.unitge.it

This script is used to define the structure of the finite state machine. Here it is initialized with all its states and their respective transitions.
For each state it is defined how to behave for each transition received so that the machine cannot be stuck or have errors in the changes.
At the beginning of the execution it is also instantiated a helper entity that is passed to each state as parameter to make it easier in some cases to use functions and shared variables. This entity is an attribute of the respective Class :mod:`helper`.
However, the main role of the helper is the sharing of the mutex that is used to access the shared variables without having troubles doing it. The mutex used is of course just one to try to have a perfect syncronization among the state and the reading/writing processes.
The finite state machine that has been created is composed of four main states: :mod:`Ã¬nit_state`, :mod:`reasoner`, *move randomly*, which is in fact a sub machine, and :mod:`recharge`.
Of course these states include many different tasks so the decision of using a sub-machine allows us to have a more modular code and a more reactive program since the execution cores of the states are not so long.
The machine is divided as follows:

* initialization phase: responsible of initialising the ontology of the environment;
* reason state: responsible of reasoning all the changes happened and computing the new location the robot has to visit (according to some statements);
* move random state: divided into :mod:`plan_path_to_location` and :mod:`go_to_location_to_visit`:
    * The first is responsible of computing a path from the actual robot position to the target position computed by the reasoner;
    * the second is responsible of moving the robot through the points of the path just computed.
* recharge state: it is responsible of recharging the robot battery. The robot can be recharged if and only if it is in the correct recharging room so there are some steps to make the robot arrive there before being recharged.

Servers:
    :attr:`sis`: this is the name that the variable of the ROS server has in the program. It is necessary for the smach ROS state machine and it is responsible of the execution of each state and their transitions.
</verbatim> </para>
    </detaileddescription>
    <location file="/root/ros_ws/src/EXPROBLAB_Assignment2/scripts/fsm.py" line="1" column="1"/>
  </compounddef>
</doxygen>
